name: Frontend Production Deployment

on:
  push:
    branches:
      - production
  workflow_dispatch: # ‚úÖ Allow manual trigger

# ‚úÖ Prevent concurrent deployments
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  NODE_VERSION: "22"
  DEPLOY_PATH: /var/www/hcmosi
  BACKUP_PATH: /var/backups/hcmosi
  BACKUP_RETENTION: 5

jobs:
  # 1Ô∏è‚É£ BUILD JOB
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15 # ‚úÖ Prevent hanging builds

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm" # ‚úÖ Cache dependencies

      - name: Generate .env file
        # The fix: Check the secret inside the 'run' command
        run: |
          if [ -n "${{ secrets.ENV_PRODUCTION }}" ]; then
            echo "${{ secrets.ENV_PRODUCTION }}" > .env
            echo "‚úÖ Environment file generated"
          else
            echo "‚ö†Ô∏è Secret ENV_PRODUCTION is empty. Skipping .env file generation."
          fi
        shell: bash

      - name: Verify .env file
        run: |
          if [ -f .env ]; then
            echo "‚úÖ .env file exists"
            echo "üìã Environment variables (masked):"
            grep -E '^[A-Z_]+=' .env | sed 's/=.*/=***/' || true
          else
            echo "‚ö†Ô∏è .env file not found"
          fi

      - name: Install dependencies
        run: npm ci # ‚úÖ Use 'ci' instead of 'install' for consistency

      - name: Build project
        run: npm run build
        env:
          CI: true # ‚úÖ Ensure build treats warnings as errors

      - name: Verify build output
        run: |
          if [ ! -d "dist" ] || [ -z "$(ls -A dist)" ]; then
            echo "‚ùå Build directory is empty or doesn't exist"
            exit 1
          fi
          echo "‚úÖ Build verification passed"

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ github.sha }}
          path: dist
          retention-days: 7 # ‚úÖ Auto cleanup old artifacts

  # 2Ô∏è‚É£ DEPLOY JOB
  deploy:
    runs-on: [self-hosted, linux, x64, frontend, production]
    needs: build
    timeout-minutes: 10

    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ github.sha }}
          path: /tmp/frontend-build

      - name: Create backup directory
        run: |
          sudo mkdir -p ${{ env.BACKUP_PATH }}
          sudo chown $USER:$USER ${{ env.BACKUP_PATH }}

      - name: Backup current deployment
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BACKUP_DIR="${{ env.BACKUP_PATH }}/backup-$TIMESTAMP"

          if [ -d "${{ env.DEPLOY_PATH }}" ] && [ "$(ls -A ${{ env.DEPLOY_PATH }})" ]; then
            cp -r ${{ env.DEPLOY_PATH }} $BACKUP_DIR
            echo "‚úÖ Backup created: $BACKUP_DIR"
            echo "BACKUP_DIR=$BACKUP_DIR" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è No existing deployment to backup"
            echo "BACKUP_DIR=" >> $GITHUB_ENV
          fi

      - name: Deploy new build
        run: |
          sudo mkdir -p ${{ env.DEPLOY_PATH }}
          sudo rm -rf ${{ env.DEPLOY_PATH }}/*
          sudo cp -r /tmp/frontend-build/* ${{ env.DEPLOY_PATH }}/
          sudo chown -R www-data:www-data ${{ env.DEPLOY_PATH }}
          sudo chmod -R 755 ${{ env.DEPLOY_PATH }}
          echo "‚úÖ Files deployed to ${{ env.DEPLOY_PATH }}"

      - name: Reload Nginx
        run: |
          sudo nginx -t  # ‚úÖ Test config before reload
          sudo systemctl reload nginx
          echo "‚úÖ Nginx reloaded successfully"

      - name: Health check
        run: |
          sleep 3
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s -o /dev/null http://localhost:80; then
              echo "‚úÖ Health check passed"
              exit 0
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Retry $RETRY_COUNT/$MAX_RETRIES..."
            sleep 2
          done

          echo "‚ùå Health check failed"
          exit 1

      - name: Rollback on failure
        if: failure() && env.BACKUP_DIR != ''
        run: |
          echo "üîÑ Rolling back to previous version..."
          sudo rm -rf ${{ env.DEPLOY_PATH }}/*
          sudo cp -r ${{ env.BACKUP_DIR }}/* ${{ env.DEPLOY_PATH }}/
          sudo chown -R www-data:www-data ${{ env.DEPLOY_PATH }}
          sudo systemctl reload nginx
          echo "‚úÖ Rollback completed"

      - name: Cleanup old backups
        if: success()
        run: |
          cd ${{ env.BACKUP_PATH }}
          BACKUP_COUNT=$(ls -1 | wc -l)

          if [ $BACKUP_COUNT -gt ${{ env.BACKUP_RETENTION }} ]; then
            ls -t | tail -n +$(({{ env.BACKUP_RETENTION }} + 1)) | xargs rm -rf
            echo "‚úÖ Cleaned up old backups (kept last ${{ env.BACKUP_RETENTION }})"
          fi

      - name: Cleanup temp files
        if: always()
        run: |
          rm -rf /tmp/frontend-build
          echo "‚úÖ Temporary files cleaned"

  # 3Ô∏è‚É£ NOTIFICATION (Optional)
  notify:
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()
    steps:
      - name: Send notification
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
            # Add your notification logic here (Slack, Discord, Email, etc)
          else
            echo "‚ùå Deployment failed!"
            # Add failure notification
          fi